---
comments: true
---

# 二叉查找树

二叉查找树的每个结点都有一个键值，每个结点都满足：

- 左子树中最大键值小于自己的键值；
- 右子树中最小键值大于自己的键值。

BST 的中序遍历结果是单调递增的。

找最大最小值按照这个子树规律查找即可。

## 插入

考虑要在某个结点的子树中插入 $x$，进行如下操作：

- 如果子树为空，直接插入 $x$，结束。
- 考虑子树的根，若根的键值若大于 $x$，在左子树中插入 $x$，递归；
- 同样，若小于 $x$，在右子树中插入 $x$，递归。

## 查询

考虑查询小于 $x$ 的最大值，进行如下操作：

- 从根节点开始；
- 如果子树为空，结束。
- 考虑子树的根，若根的键值大于等于 $x$，向左子树查询，递归；
- 同样，若小于 $x$，更新答案，向右子树查询，递归。

求排名就是二分，需要额外维护每个结点子树大小。

## 删除

删除 $x$：

- 找到 $x$；
- 是叶子直接删。
- 只有一个儿子直接删，儿子上来。
- 否则用左子树最大值或右子树最小值替代掉 $x$，再删掉。

## 时间复杂度

插入和查询复杂度都是 $O(\log n)$，但 BST 是有风险退化成链表的，这样一次操作就是 $O(n)$ 的。

要避免出现这种情况，可以使用 [平衡树](./balanced_tree.md)。