---
comments: true
---

# 并查集

## 初始化

初始每个节点都是只包含自己的一棵树，所以将每个结点的父亲设置为他自己。

## 查询父亲

``` cpp
int find(int x) {
    return fa[x] == x ? x : find(fa[x]);
}
```

### 路径压缩

改变树的结构不改变其连通性，查询完一个点的根，直接把他的父亲设置为根即可。

这样每次找根遍历的边就少了。

``` cpp
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}
```

## 合并

``` cpp
void merge(int x, int y) {
    fa[find(x)] = find(y);
}
```

### 按秩合并（启发式合并）

对于每个根节点都维护他子树的大小，合并的时候小树当大树的儿子，时间上更快。

``` cpp
void merge(int x, int y) {
    x = find(x), y = find(y);
    if(sz[x] < sz[y]) std::swap(x, y);
    fa[x] = y;
}
```

## 复杂度

空间复杂度 $O(n)$。

对于同时使用路径压缩和按秩合并优化的不交集森林，每个查询和合并操作的平均时间复杂度仅为 $O(\alpha(n))$，$\alpha(n)$ 是反阿克曼函数。由于阿克曼函数增加极度迅速，所以 $\alpha(n)$ 增长极度缓慢，对于任何在实践中有意义的元素数目 $n$，$\alpha(n)$ 均小于5，因此，也可以粗略地认为，并查集的操作有常数的时间复杂度。

实际上，这是渐近最优算法：Fredman 和 Saks 在 1989 年证明了任何并查集都需要 $\Omega(\alpha(n))$ 的均摊时间来完成每次操作。[^1]

[^1]: 摘自 [维基百科](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)。

## 可撤销并查集

合并时记下新的边，撤销就把它删除掉，再重新计算分开之后两棵子树大小。

!!! warning

    可撤销并查集不能使用路径压缩，否则时间复杂度无法保证。