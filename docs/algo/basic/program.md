---
comments: true
---

# 程序设计

## 概念

算法是一些指令的有限序列，每一条指令都表示一个或多个操作。

一个算法必须满足：**有穷性**、**确定性**、**可行性**、**没有/有输入** 和 **有至少一个输出**。

算法的基本结构有：**顺序结构**、**选择结构** 和 **循环结构**。

## 排序

[维基百科](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95) 和 [OI Wiki](https://oi-wiki.org/basic/sort-intro/) 应该讲的比我详细。

你维的表挺好的我就直接搬过来了（（（精简掉了对 OI 没用的内容

复杂度中的 $n$ 是序列长度，$m$ 是值域大小，$k$ 为序列中数最大长度。

| 名称 | 是否稳定 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度（另外） | 如何实现 |
| ---- | ----- | ------------ | ------------ | --------------- | ------ |
| 冒泡排序 | <span style="color: #8bc34a">Yes</span> | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 算法中，有序区间在序列最后，当无序区间非空时使用交换找出最大元素并放到有序区间最前面。 |
| 选择排序 | <span style="color: #ff5722">No</span> | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 算法中，有序区间在序列最前，当无序区间非空时找出最小元素并放在有序区间最后面。 |
| 插入排序 | <span style="color: #8bc34a">Yes</span> | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 算法中，有序区间在序列最前，当无序区间非空时将其最前面的元素放在有序区间的一定位置。 |
| 堆排序 | <span style="color: #ff5722">No</span> | $O(n\log n)$ | $O(n\log n)$ | $O(1)$ | 算法中，开一个堆记录原序列的元素，每次将堆的根放到排序好的序列中，再恢复堆。 |
| 归并排序 | <span style="color: #8bc34a">Yes</span> | $O(n\log n)$ | $O(n\log n)$ | $O(n+\log n)$ | 算法中，将待排序序列分为两部分，逐个选取最小元素放到排序好的序列的末尾。 |
| 快速排序 | <span style="color: #ff5722">No</span> | $O(n\log n)$ | $O(n^2)$ | $O(\log n)$ | 算法中，在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 |
| 内省排序 | <span style="color: #ff5722">No</span> | $O(n\log n)$ | $O(n\log n)$ | $O(\log n)$ | 其实就是快速排序，但当其递归层数过大时转换成堆排序，确保不会退化到 $O(n^2)$。 |
| 希尔排序 | <span style="color: #ff5722">No</span> | $O(n\log^2 n)$ | $O(n^2)$ | $O(1)$ | 算法中，每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定减少到 $1$。 |
| 计数排序 | <span style="color: #8bc34a">Yes</span> | $O(n+m)$ | $O(n+m)$ | $O(n+m)$ | 算法中，计算每个数出现了几次，求出它们的前缀和，从右到左计算他们的排名。 |
| 桶排序 | <span style="color: #8bc34a">Yes</span> | $O(n)$ | $O(n^2)$ | $O(m)$ | 算法中，开 $m$ 个桶并将元素记录到桶中，再将桶中元素恢复成序列。 |
| 基数排序 | <span style="color: #8bc34a">Yes</span> | 视内层算法为 $O(kn)$ 或 $O(kn+m)$ 等 | $O(n^2)$ | 视内层算法 | 这是一个多关键字的排序算法，内层算法一般为桶排或计数。 |

!!! info

    `std::sort` 一般是内省排序实现，gcc 和 clang 都是内省排序（因为 C++11 要求 `std::sort` 的最坏时间复杂度不得高于 $O(n\log n)$）。

    `std::stable_sort` 是他的稳定版本。

    `std::nth_element` 用于求出序列中第 $k$ 大的数，原理是跑一半内省排序。C++ 标准要求其平均复杂度不得高于 $O(n)$。

有时间就多上 OI Wiki 读一下实现代码，初赛程序题还是有不小概率考排序的。

## 位运算

### 按位与运算（&）

两个二进制数进行与运算，如果对应位上两数都为 $1$，则该位为 $1$，反之为 $0$。

### 按位或运算（|）

两个二进制数进行或运算，如果对应位上两数都为 $0$，则该位为 $0$，反之为 $1$。

### 异或运算（^）

两个二进制数进行异或运算，如果对应位上两数不同，则该位为 $1$，反之为 $0$。

!!! tip

    异或满足交换律和结合律。

    一个数异或 $0$ 是他自己，异或他自己是 $0$。

### 按位取反（~）

就是将一个二进制数的各位数码都取反，包括符号位。

### 左移运算（<<）

将一个二进制数整体向左移动若干位，低位用 $0$ 补全。

### 右移运算（>>）

将一个二进制数整体向右移动若干位，多余的舍去。

### 位运算优先级

从高到低：

按位取反、位移、按位与、异或、按位或。

### 常用技巧

**lowbit（取出最后一个 1）**：`a & (-a)`。

**取得第 x 位**：`a & (1 << x)`。

**设置第 x 位为 1**：`a |= (1 << x)`。

**设置第 x 位为 0**：`a &= ~(1 << x)`。

## 逻辑运算

### 逻辑与（&&）

数学中记作 $\land$。

两个逻辑变量都为真时，结果为真，反之为假。

### 逻辑或（||）

数学中记作 $\lor$。

两个逻辑变量都为假时，结果为假，反之为真。

### 逻辑非（!）

数学中记作 $\lnot$。

该逻辑变量为真时，结果为假，反之为真。

### 逻辑运算优先级

从高到低：

非、与、或。

### 真、假

在 C++ 中，真表示为 `true`，任何非 $0$ 值转换到 `bool` 类型都是 `true`。

假表示为 `false`，$0$ 值转换到 `bool` 类型是 `false`。


## 图论

### 一些基本概念

对于两个点 $u, v$，若存在边 $(u, v)$，称 $u, v$ 是 **相邻的**。

与一个点 $u$ 关联的边数记作他的 **度数**，下记点 $u$ 的度数为 $\deg(u)$。

**无向图中度数是边数的两倍（握手定理）**，形式化地，$2|E| = \sum\limits_{x\in V} \deg(x)$。

若 $\deg(u)=0$，$u$ 是 **孤立点**。若 $\deg(u)=1$，$u$ 是 **叶节点**。若 $2\mid \deg(u)$，$u$ 是 **偶点**，反之 $u$ 是 **奇点**。

---

**自环** 就是一条边 $e=(u, v)$ 满足 $u=v$。

**重边** 就是存在两条边完全相等。

不存在自环、重边的图是 **简单图**，反之是 **多重图**。

---

**稀疏图** 就是满足 $|V|^2\gg |E|$ 的图，**稠密图** 就是满足 $|V|^2\approx |E|$ 的图。

### 连通性

记一个无向图 $G=(V, E)$，有向图 $H=(V', E')$：

- 若 $G$ 中任意两个顶点均连通，则 $G$ 是 **连通图**。
- 若 $G$ 存在一个连通子图 $G'$，并且不存在任意的连通图 $G''$ 使得 $G'\subsetneq G''\subseteq G$，则 $G'$ 是 $G$ 是的一个 **连通分量**。
- 若 $H$ 中任意两个顶点可互相到达，则 $H$ 是 **强连通图**。
- 若将 $H$ 转换为无向图后图连通，则 $H$ 是 **弱连通图**。
- 根据连通分量的定义，同样也有 **强连通分量** 和 **弱连通分量**。

### 一些特殊的图

记一个无向简单图 $G=(V, E)$，有向简单图 $H=(V', E')$：

- 若 $G$ 中任意两点之间均有边，则 $G$ 是 **完全图**。
- 若 $H$ 中任意两点之间均有两条方向不同的边，则 $H$ 是 **有向完全图**。
- 若 $H$ 中任意两点之间恰有一条边，则 $H$ 是 **竞赛图**。
- 若 $E=\varnothing$，则该图是一张 **空图（零图）**。
- 若 $G$ 中所有边恰好构成一个圆圈，则 $G$ 是 **环图**。
- 若 $G$ 中所有边恰好构成一条路径，则 $G$ 是 **链**。链就是环图删去一条边。
- 若 $G$ 中存在一个支配点 $u$ 满足其余点两两之间没有边，则 $G$ 是 **菊花图**。
- 若 $G$ 中存在一个支配点 $u$ 满足其余点之间的边构成一个圆圈，则 $G$ 是 **轮图**。
- 若 $G$ 连通，且不含环，则 $G$ 是 **树**。
- 若 $G$ 连通，且恰好含一个环，则 $G$ 是 **基环树**。
- 若 $H$ 弱连通，且每个点出度恰为 $1$，则 $H$ 是 **内向基环树**。
- 若 $H$ 弱连通，且每个点入度恰为 $1$，则 $H$ 是 **外向基环树**。
- 若 $G$ 连通，且每条边都在一个环里，则 $G$ 是 **仙人掌**。
- 若一张图的点集分为两部分后，每个部分内部没有连边，则它是 **二分图**。在此基础上若任意两个来自不同部分的点之间都有连边，则它是 **完全二分图**。

多个特殊图可以构成一个图的集合：

- 多棵树构成 **森林**。
- 多棵基环树构成 **基环森林**。
- 多棵内向基环树构成 **内向基环森林**。
- 多棵外向基环树构成 **外向基环森林**。
- 多棵仙人掌构成 **沙漠**。

一些特殊图有特殊的记法：

- $K_n$ 是 $n$ 阶完全图。
- $N_n$ 是 $n$ 阶空图。
- $C_n$ 是 $n(n>2)$ 阶环图。
- $P_n$ 是 $n$ 阶链。
- $W_n$ 是 $n+1(n>2)$ 阶轮图。
- $S_n$ 是 $n+1(n>0)$ 阶菊花图。
- $K_{n,m}$ 是两个部分分别有 $n$ 和 $m$ 个节点的完全二分图。

一些特殊图满足一些性质：

- 完全图有 $\dfrac{n(n+1)}{2}$ 条边。
- 树有 $n-1$ 条边。

## 二叉树

单独开了个大标题，因为初赛真的很喜欢考二叉树。

记一棵有根树 $G=(V, E)$：

- 若 $G$ 中每个节点最多只有两个儿子，则 $G$ 是一棵 **二叉树**。
- 若 $G$ 是一棵二叉树，且每个节点要么是叶子，要么有 $2$ 个儿子，则 $G$ 是一棵 **完整二叉树**。
- 若 $G$ 是一棵二叉树，且只有最后一层节点不满，且最后一层节点都集中在最左边的连续位置上，则 $G$ 是一棵 **完全二叉树**。
- 若 $G$ 是一棵二叉树，且叶子节点都在同一层，且非叶子节点都有 $2$ 个儿子，则 $G$ 是一棵 **完美二叉树（满二叉树）**。

二叉树常考的性质有：

1. 二叉树的第 $x$ 层最多有 $2^{x-1}$ 个节点。
2. 任何二叉树都满足叶子节点数等于有两个儿子的节点数加一。
3. 深 $d$ 层的二叉树最多有 $2^d-1$ 个节点。
4. 完全二叉树的节点总数是叶子的两倍再减一。
5. 有 $n$ 个节点的完全二叉树的深度是 $\lfloor\log n\rfloor +1$。

初赛还很喜欢考先/中/后序遍历。

=== "先序遍历"

    根据 **根、左、右** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            res.push_back(now->val);
            dfs(now->left);
            dfs(now->right);
        }
    }
    ```

=== "中序遍历"

    根据 **左、根、右** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            dfs(now->left);
            res.push_back(now->val);
            dfs(now->right);
        }
    }
    ```

=== "后序遍历"

    根据 **左、右、根** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            dfs(now->left);
            dfs(now->right);
            res.push_back(now->val);
        }
    }
    ```

知道中序遍历序列和其他任意一个序列可以反推出整棵树，只需依照以下步骤：

1. 前序序列中第一个是根，后续序列中最后一个是根。
2. 确定根之后，中序遍历序列中，根左边是左子树，根右边是右子树。
3. 递归。


## 数据结构

### 栈（Stack）

栈是后进先出的，称为 LIFO（Last In First Out）表。

### 队列（Queue）

队列是先进先出的，称为 FIFO（First In First Out）表。

### 链表（List）

链表插入删除 $O(1)$，随机访问 $O(n)$。数组正好相反。

常见链表的声明形式：

=== "单向链表"

    存储数据和他的后继。

    ``` cpp 
    template <class T>
    struct node {
        T val;
        node *nxt;
    };
    ```

=== "双向链表"

    存储数据、他的前驱和后继。

    ``` cpp
    template <class T>
    struct node {
        T val;
        node *prv, *nxt;
    };
    ```

初赛常考的就是要在链表中插入 / 删除元素，给你列四个选项判断哪个正确 / 错误，这个时候我们需要注意的就是修改的顺序。

``` cpp
// 示例：双向链表，在 x 后插入 y

// 这段代码是正确的
y->nxt = x->nxt; // 插入后，x 的后继变成了 y 的后继
x->nxt->prv = y; // 插入后，x 的后继的前驱变成了 y
y->prv = x; // y 的前驱是 x
x->nxt = y; // x 的后继是 y

// 这段代码是错误的
y->prv = x;
y->nxt = x->nxt;
x->nxt = y;
x->nxt->prv = y; // 此时因为上一句的修改，x 的后继已经成为 y 了，y 的前驱不可能是 y 吧？
```

链表可能是初赛常考的数据结构中最抽象、最不好懂的，可以在纸上自己练习一下。

### 字符串（String）

没啥好讲的。

$|s|$ 指字符串 $s$ 的长度。

子串是从字符串的某个位置开始取若干个字符组成的字符串，空串是任何字符串的子串。子串个数计算：$\dfrac{n(n+1)}{2}+1$。

子序列是在字符串中删除若干字符组成的字符串。

字典序比较就是以第 $i$ 个字符作为第 $i$ 关键字比较，一般而言空字符小于任何字符。


## 数学

!!! tip

    数学是非常重要的一部分。

    普及小朋友们照着大纲基本没问题。

    提高 / NOIP 的同学们建议复习复习 CRT、扩欧、裴蜀定理、费马小定理、欧拉函数、错排、鸽巢、容斥、二项式定理、向量和矩阵等等就行了，这些是初赛可能考的。

### 组合数学

咱也不知道为啥初赛特别喜欢考排列组合。

建议学一学（or 复习）数学选修二相关内容。

#### 排列

$n$ 个不同元素中选 $m$ 个元素，考虑顺序。

$n=m$ 时称为全排列。

$P^m_n=\dfrac{n!}{(n-m)!}$

#### 组合

$n$ 个不同元素中选 $m$ 个元素，不考虑顺序。

计算组合数就是计算对应排列数后把顺序除掉就好了。

$C^m_n=\dfrac{P^m_n}{P^m_m}=\dfrac{n!}{m!(n-m)!}$