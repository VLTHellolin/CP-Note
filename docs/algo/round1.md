---
comments: true
---

# 初赛总结

祝各位看完本文后 CSP / NOIP RP++！

!!! abstract

    这篇文章前半部分是关于计算机科学的，了解个大概就行，虽然这部分题多但都不会很难很偏。

    建议普及的同学们多看看后半部分的算法内容，提高 / NOIP 的同学们记得多复习数学。

!!! tip

    关于刷题：题目资源少我知道，如果你 CSP / NOIP 的初赛题都已经看完，并且一本通的初赛题库也差不多了，那么就放平心态考就好（考提高 / NOIP 的同学别把数学落下了）。

## NOI 系列活动

实在太多了不一一说明了。

活动规则请参阅：

- [CCF CSP-JS认证须知](https://noi.cn/gynoi/tlgd/2019-09-30/710460.shtml)
- [CCF NOI系列活动考场须知](https://noi.cn/gynoi/tlgd/2019-09-30/710458.shtml)
- [NOI竞赛规则](https://noi.cn/gynoi/tlgd/2009-09-17/710430.shtml)
- [关于CCF非专业认证和竞赛中的违规处罚规则](https://noi.cn/gynoi/tlgd/2020-12-10/718308.shtml)
- [全国青少年信息学奥林匹克竞赛 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%9B%BD%E9%9D%92%E5%B0%91%E5%B9%B4%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E7%AB%9E%E8%B5%9B)
- [全国青少年信息学奥林匹克联赛 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%9B%BD%E9%9D%92%E5%B0%91%E5%B9%B4%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E8%81%94%E8%B5%9B)

活动历史请参阅：

- [CCF大事记](https://www.ccf.org.cn/About_CCF/Key_Milestone/)
- [全国青少年信息学奥林匹克竞赛 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%9B%BD%E9%9D%92%E5%B0%91%E5%B9%B4%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E7%AB%9E%E8%B5%9B)
- [全国青少年信息学奥林匹克联赛 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%9B%BD%E9%9D%92%E5%B0%91%E5%B9%B4%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E8%81%94%E8%B5%9B)

## 计算机史

关于这部分年代应该不会考的太准确。

| 名称 | 年代 | 发明 / 制造人 | 代表机型 |
| --- | ---- | ---------- | ------ |
| 真空管计算机 | 1801 | 法国人约瑟夫·杰夸德 | 打孔卡 |
| 真空管计算机 | 1822、1837 | 英国人查尔斯·巴贝奇（“电脑之父”） | 差分机、分析机 |
| 真空管计算机 | 1946 | 美国人莫克利以及艾克特 | ENIAC（埃尼阿克） |
| 晶体管计算机 | 1954 | 美国贝尔实验室 | TRADIC（催迪克） |
| 集成电路计算机 | 1958 | 美国人杰克·基尔比 | IBM 的 System/360 |
| 超大规模集成电路计算机 | 1977 | \ | ILLIAC-IV、Macintosh |
| 智能计算机 | 至今 | \ | \ |

## 计算机应用

计算机拥有快速性、通用性、准确性和逻辑性等特点。

1. 科学计算：在科研、工程等领域完成大量复杂的计算。这是计算机的基本应用。
2. 信息处理：对数据进行收集、存储、整理、分类、统计、加工、利用、传播等活动。计算机主要应用。
3. 自动控制：利用计算机及时采集、检测数据，按照最优值迅速控制对象进行自动调节、自动控制。
4. 计算机辅助技术：利用计算机帮助人们设计、处理。
5. 人工智能：利用计算机模拟人类的智能活动。
6. 网络应用：利用计算机进行网络相关活动。

## 计算机领域有关名人

- 第一位程序员：英国 埃达·洛夫莱斯
- 计算机科学之父：英国 艾伦·图灵
- 计算机之父、提出存储程序控制原理的：匈牙利（美籍） 约翰·冯·诺依曼
- 信息论的创始人（引入熵的）：美国 克劳德·香农

## 计算机学奖项

### 图灵奖

**图灵奖**（ACM Turing Award），由 ACM 于 1966 年设立，授予对象是 **为计算机科学作出重要贡献的个人**。是计算机最高奖项（“计算机界的诺贝尔奖”）。

图灵奖获得者见 [维基百科](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96)，[姚期智](https://zh.wikipedia.org/wiki/%E5%A7%9A%E6%9C%9F%E6%99%BA) 是 **唯一一位获此奖的华人** ，于 2000 年获得图灵奖。清华大学的 **姚班** 就是以他命名的。

### 约翰·冯·诺依曼奖

**约翰·冯·诺依曼奖**（IEEE John von Neumann Medal），由 IEEE 于 1990 年设立，目的是 **表扬在计算机科学和技术上具有杰出成就的科学家**。

## 计算机网络

定义是利用通信线路和设备，将不同地方的计算机连接起来。

### 互联网协议套件（IPS）

[维基百科](https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F) 应该讲的比我好。

分为 **应用层**（DNS、FTP、HTTP(S)、POP、SSH等）、**传输层**（TCP、UDP等）、**网络层**（IP、ECN等）、**链接层**（MAC、Ethernet等）。

### IPv4

四个以点分割的十进制数组成一个 IPv4 地址，这四个数都在 $0$ 和 $255$ 之间。

### IPv6

八个以冒号分割的十六进制数组成一个 IPv6 地址，地址中若含有前导零是可以舍去的。

### 常用缩写

- 局域网，LAN，Local Area Network
- 城域网，MAN，Metropolitan Area Network
- 广域网，WAN，Wide Area Network
- 万维网，WWW，World Wide Web
- 传输控制协议，TCP，Transmission Control Protocol
- 网际协议，IP，Internet Protocol
- 域名系统，DNS，Domain Name System
- 超文本标记语言，HTML，HyperText Markup Language
- 超文本传输协议，HTTP，HyperText Transfer Protocol
- 超文本传输安全协议，HTTPS，HyperText Transfer Protocol Secure
- 文件传输协议，FTP，File Transfer Protocol
- 因特网信息访问协议，IMAP，Internet Message Access Protocol
- 简单邮件传输协议，SMTP，Simple Mail Transfer Protocol
- 邮局协议，POP，Post Office Protocol
- 统一资源定位符，URL，Uniform Resource Locator
- 统一资源标识符，URI，Uniform Resource Identifier

## 计算机构成

**微型计算机** 分为 **硬件系统** 和 **软件系统**，**硬件系统** 分主板、CPU、存储器（内存储器、外存储器）、电源、I/O 设备等，**软件系统** 分系统软件（操作系统、诊断程序等）和应用软件。

### 中央处理器（CPU）

CPU 的功能是 **解释计算机指令以及处理计算机软件中的数据**。

CPU 由 **运算器、控制器和存储器** 组成。

几乎所有的冯·诺伊曼 CPU 的运作原理可分为四个阶段：**提取、解码、执行和写回**。

CPU 的 **主频=外频×倍频**。CPU 性能取决于 **时钟频率** 和 **IPC**（每周期可处理的指令），IPS（每秒可处理的指令）就是时钟频率和 IPC 的结合。

CPU访问速度（由高到低）：寄存器、高速缓存、内存、外存。

### 存储器

#### 随机存取存储器（RAM）

RAM 是 **内存储器**。

RAM 与中央处理器直接交换数据。

#### 只读存储器（ROM）

ROM 是 **内存储器**。

一旦存储了资料不可再改写。其中的数据不会因为断电而丢失。

!!! info

    BIOS（Basic Input and Output System，基本输入输出系统）就是一组固化到主板上的 ROM 内的程序，其为计算机提供最底层、最直接的硬件控制，其中保存着计算机的自检程序、自启动程序等。

### 外存储器

外存储器包括硬盘、光盘等。

### 输入输出（I/O）设备

键盘、鼠标、扫描仪、相机等都是输入设备。

打印机、投影仪、显示器、扬声器等都是输出设备。

也有双向的设备，RAM、触摸屏、USB、刻录机等都是双向设备。

### 断电后可不可以保存数据？

可以：ROM、外存储器。

不可以：CPU、RAM。

## 编程语言

编程语言分为低级语言和高级语言。

### 低级语言和高级语言

常见低级语言是汇编语言。

常见高级语言有 C/C++、Fortran、Java 等。

!!! info

    **低级语言和高级语言的主要区别** 是低级语言常数小、运行快，而高级语言需要编译/解释，常数大、运行慢，但可移植性高。

### 面向过程和面向对象

面向过程的语言有 C、Fortan、Pascal、Basic 等。

面向对象的语言有 C++、Java、Javascript、Swift、PHP、Ruby、Objective-C 等。

### 编译型语言和解释型语言

编译型语言执行的步骤如下：

1. 交给编译器，将源代码翻译成指令。
2. 再交给链接器，将指令链接到一块，形成可执行程序。

常见编译型语言有 C/C++、Pascal、Ruby 等。

解释型语言执行就是一行一行扫描解释。

常见解释型语言有 Python、PHP、Basic 等。

有些语言需要先编译后解释，比如 Java 和 Lua 等，带编译器和解释器，编译器先编译成字节码，再由解释器解释执行（其实 Python 也可以先编译后解释）。

## 存储单位

!!! warning

    微软操作系统中经常混用 MB、MiB 等存储单位，**在考试中出现的 MB 一般指 MiB，GB 一般指 GiB**，请仔细辨别。

常用的存储单位有 **B / KB / KiB / MB / MiB / GB / GiB / TB / TiB / PB / PiB** 等。**B** 指字节（Byte）。

不带 **i** 的这些 Bytes，进位关系是 **1000**。

带 **i** 的这些 Bytes，进位关系是 **1024**。

还有一种单位是 **b** 比特（bit），相应的有 **Kb / Kib / Mb / Mib** 等。

**1B = 8b**，一字节含有八个比特，比特是二进制下的一位内存。

## Linux、编译工具、IDE 或编辑器、调试工具

多用用就会了。

## 进制转换

**Hex** 表示 Hexadecimal，16 进制。

**Dec** 表示 Decimal，10 进制。

**Oct** 表示 Octomary，8 进制。

**Bin** 表示 Binary，2 进制。

### 十进制转 k 进制

短除法，把十进制数每次除以 $k$ 求余数，最后把余数倒序排列即可。

小数就是换成乘法，将取整结果写出，正序排列即可。

### k 进制转十进制

第 $i$ 位乘上 $k^{i-1}$，相加即可。

小数就是变为负指数。

### x 进制转 y 进制

x 进制转到十进制再转 y 进制。

## 二进制

计算机计算使用二进制。

最高位是符号位，其余部分正常存储数字（称为真值）。

**原码** 就是将十进制数直接转换为二进制数形成的二进制编码，直接用符号+真值表示。

**反码** 正数的反码是自己，负数的反码是真值部分全部按位取反的结果。

**补码** 正数的补码是自己，负数的补码是反码加一。

## 位运算

### 按位与运算（&）

两个二进制数进行与运算，如果对应位上两数都为 $1$，则该位为 $1$，反之为 $0$。

### 按位或运算（|）

两个二进制数进行或运算，如果对应位上两数都为 $0$，则该位为 $0$，反之为 $1$。

### 异或运算（^）

两个二进制数进行异或运算，如果对应位上两数不同，则该位为 $1$，反之为 $0$。

异或满足交换律和结合律。

一个数异或 $0$ 是他自己，异或他自己是 $0$。

### 按位取反（~）

就是将一个二进制数的各位数码都取反，包括符号位。

### 左移运算（<<）

将一个二进制数整体向左移动若干位，低位用 $0$ 补全。

### 右移运算（>>）

将一个二进制数整体向右移动若干位，多余的舍去。

### 位运算优先级

从高到低：

按位取反、位移、按位与、异或、按位或。

### 常用技巧

**lowbit（取出最后一个 1）**：`a & (-a)`。

**取得第 x 位**：`a & (1 << x)`。

**设置第 x 位为 1**：`a |= (1 << x)`。

**设置第 x 位为 0**：`a &= ~(1 << x)`。

## 逻辑运算

### 逻辑与（&&）

数学中记作 $\land$。

两个逻辑变量都为真时，结果为真，反之为假。

### 逻辑或（||）

数学中记作 $\lor$。

两个逻辑变量都为假时，结果为假，反之为真。

### 逻辑非（!）

数学中记作 $\lnot$。

该逻辑变量为真时，结果为假，反之为真。

### 逻辑运算优先级

从高到低：

非、与、或。

### 真、假

在 C++ 中，真表示为 `true`，任何非 $0$ 值转换到 `bool` 类型都是 `true`。

假表示为 `false`，$0$ 值转换到 `bool` 类型是 `false`。

## ASCII

常考：

1. 阿拉伯数字 $0$ 到 $9$（`48` 到 `57`）。
2. 26 个大写英文字母（`65` 到 `90`）。
3. 26 个小写英文字母（`97` 到 `122`）。
4. 控制符（空格换行退格等等）。

## 汉字交换码

一级汉字拼音排序，二级汉字部首排序。

## 数学

!!! tip

    数学是非常重要的一部分。

    普及小朋友们照着大纲基本没问题。

    提高 / NOIP 的同学们建议复习复习 CRT、扩欧、裴蜀定理、费马小定理、欧拉函数、错排、鸽巢、容斥、二项式定理、向量和矩阵等等就行了，这些是初赛可能考的。

### 组合数学

咱也不知道为啥初赛特别喜欢考排列组合。

建议学一学（or 复习）数学选修二相关内容。

#### 排列

$n$ 个不同元素中选 $m$ 个元素，考虑顺序。

$n=m$ 时称为全排列。

$P^m_n=\dfrac{n!}{(n-m)!}$

#### 组合

$n$ 个不同元素中选 $m$ 个元素，不考虑顺序。

计算组合数就是计算对应排列数后把顺序除掉就好了。

$C^m_n=\dfrac{P^m_n}{P^m_m}=\dfrac{n!}{m!(n-m)!}$

## 数据结构

### 栈（Stack）

栈是后进先出的，称为 LIFO（Last In First Out）表。

### 队列（Queue）

队列是先进先出的，称为 FIFO（First In First Out）表。

### 链表（List）

链表插入删除 $O(1)$，随机访问 $O(n)$。数组正好相反。

常见链表的声明形式：

=== "单向链表"

    存储数据和他的后继。

    ``` cpp 
    template <class T>
    struct node {
        T val;
        node *nxt;
    };
    ```

=== "双向链表"

    存储数据、他的前驱和后继。

    ``` cpp
    template <class T>
    struct node {
        T val;
        node *prv, *nxt;
    };
    ```

初赛常考的就是要在链表中插入 / 删除元素，给你列四个选项判断哪个正确 / 错误，这个时候我们需要注意的就是修改的顺序。

``` cpp
// 示例：双向链表，在 x 后插入 y

// 这段代码是正确的
y->nxt = x->nxt; // 插入后，x 的后继变成了 y 的后继
x->nxt->prv = y; // 插入后，x 的后继的前驱变成了 y
y->prv = x; // y 的前驱是 x
x->nxt = y; // x 的后继是 y

// 这段代码是错误的
y->prv = x;
y->nxt = x->nxt;
x->nxt = y;
x->nxt->prv = y; // 此时因为上一句的修改，x 的后继已经成为 y 了，y 的前驱不可能是 y 吧？
```

链表可能是初赛常考的数据结构中最抽象、最不好懂的，可以在纸上自己练习一下。

### 字符串（String）

没啥好讲的。

$|s|$ 指字符串 $s$ 的长度。

子串是从字符串的某个位置开始取若干个字符组成的字符串，空串是任何字符串的子串。子串个数计算：$\dfrac{n(n+1)}{2}+1$。

子序列是在字符串中删除若干字符组成的字符串。

字典序比较就是以第 $i$ 个字符作为第 $i$ 关键字比较，一般而言空字符小于任何字符。

## 排序

[维基百科](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95) 和 [OI Wiki](https://oi-wiki.org/basic/sort-intro/) 应该讲的比我详细。

你维的表挺好的我就直接搬过来了（（（精简掉了对 OI 没用的内容

复杂度中的 $n$ 是序列长度，$m$ 是值域大小，$k$ 为序列中数最大长度。

| 名称 | 是否稳定 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度（另外） | 如何实现 |
| ---- | ----- | ------------ | ------------ | --------------- | ------ |
| 冒泡排序 | <span style="color: #8bc34a">Yes</span> | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 算法中，有序区间在序列最后，当无序区间非空时使用交换找出最大元素并放到有序区间最前面。 |
| 选择排序 | <span style="color: #ff5722">No</span> | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 算法中，有序区间在序列最前，当无序区间非空时找出最小元素并放在有序区间最后面。 |
| 插入排序 | <span style="color: #8bc34a">Yes</span> | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 算法中，有序区间在序列最前，当无序区间非空时将其最前面的元素放在有序区间的一定位置。 |
| 堆排序 | <span style="color: #ff5722">No</span> | $O(n\log n)$ | $O(n\log n)$ | $O(1)$ | 算法中，开一个堆记录原序列的元素，每次将堆的根放到排序好的序列中，再恢复堆。 |
| 归并排序 | <span style="color: #8bc34a">Yes</span> | $O(n\log n)$ | $O(n\log n)$ | $O(n+\log n)$ | 算法中，将待排序序列分为两部分，逐个选取最小元素放到排序好的序列的末尾。 |
| 快速排序 | <span style="color: #ff5722">No</span> | $O(n\log n)$ | $O(n^2)$ | $O(\log n)$ | 算法中，在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。 |
| 内省排序 | <span style="color: #ff5722">No</span> | $O(n\log n)$ | $O(n\log n)$ | $O(\log n)$ | 其实就是快速排序，但当其递归层数过大时转换成堆排序，确保不会退化到 $O(n^2)$。 |
| 希尔排序 | <span style="color: #ff5722">No</span> | $O(n\log^2 n)$ | $O(n^2)$ | $O(1)$ | 算法中，每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定减少到 $1$。 |
| 计数排序 | <span style="color: #8bc34a">Yes</span> | $O(n+m)$ | $O(n+m)$ | $O(n+m)$ | 算法中，计算每个数出现了几次，求出它们的前缀和，从右到左计算他们的排名。 |
| 桶排序 | <span style="color: #8bc34a">Yes</span> | $O(n)$ | $O(n^2)$ | $O(m)$ | 算法中，开 $m$ 个桶并将元素记录到桶中，再将桶中元素恢复成序列。 |
| 基数排序 | <span style="color: #8bc34a">Yes</span> | 视内层算法为 $O(kn)$ 或 $O(kn+m)$ 等 | $O(n^2)$ | 视内层算法 | 这是一个多关键字的排序算法，内层算法一般为桶排或计数。 |

`std::sort` 一般是内省排序实现（因为 C++11 要求 `std::sort` 的最坏时间复杂度不得高于 $O(n\log n)$）。

`std::stable_sort` 是他的稳定版本。

`std::nth_element` 用于求出序列中第 $k$ 大的数，原理是跑一半内省排序。C++ 标准要求其平均复杂度不得高于 $O(n)$。

有时间就多上 OI Wiki 读一下实现代码，初赛程序题还是有不小概率考排序的。

## 图论

### 一些基本概念

若对于两个点 $u, v$，若存在边 $(u, v)$，称 $u, v$ 是 **相邻的**。

与一个点 $u$ 关联的边数记作他的 **度数**，下记点 $u$ 的度数为 $\deg(u)$。

**无向图中度数是边数的两倍（握手定理）**，形式化地，$2|E| = \sum\limits_{x\in V} \deg(x)$。

若 $\deg(u)=0$，$u$ 是 **孤立点**。若 $\deg(u)=1$，$u$ 是 **叶节点**。若 $2\mid \deg(u)$，$u$ 是 **偶点**，反之 $u$ 是 **奇点**。

---

**自环** 就是一条边 $e=(u, v)$ 满足 $u=v$。

**重边** 就是存在两条边完全相等。

不存在自环、重边的图是 **简单图**，反之是 **多重图**。

---

**稀疏图** 就是满足 $|V|^2\gg |E|$ 的图，**稠密图** 就是满足 $|V|^2\approx |E|$ 的图。

### 连通性

记一个无向图 $G=(V, E)$，有向图 $H=(V', E')$：

- 若 $G$ 中任意两个顶点均连通，则 $G$ 是 **连通图**。
- 若 $G$ 存在一个连通子图 $G'$，并且不存在任意的连通图 $G''$ 使得 $G'\subsetneq G''\subseteq G$，则 $G'$ 是 $G$ 是的一个 **连通分量**。
- 若 $H$ 中任意两个顶点可互相到达，则 $H$ 是 **强连通图**。
- 若将 $H$ 转换为无向图后图连通，则 $H$ 是 **弱连通图**。
- 根据连通分量的定义，同样也有 **强连通分量** 和 **弱连通分量**。

### 一些特殊的图

记一个无向简单图 $G=(V, E)$，有向简单图 $H=(V', E')$：

- 若 $G$ 中任意两点之间均有边，则 $G$ 是 **完全图**。
- 若 $H$ 中任意两点之间均有两条方向不同的边，则 $H$ 是 **有向完全图**。
- 若 $H$ 中任意两点之间恰有一条边，则 $H$ 是 **竞赛图**。
- 若 $E=\varnothing$，则该图是一张 **空图（零图）**。
- 若 $G$ 中所有边恰好构成一个圆圈，则 $G$ 是 **环图**。
- 若 $G$ 中所有边恰好构成一条路径，则 $G$ 是 **链**。链就是环图删去一条边。
- 若 $G$ 中存在一个支配点 $u$ 满足其余点两两之间没有边，则 $G$ 是 **菊花图**。
- 若 $G$ 中存在一个支配点 $u$ 满足其余点之间的边构成一个圆圈，则 $G$ 是 **轮图**。
- 若 $G$ 连通，且不含环，则 $G$ 是 **树**。
- 若 $G$ 连通，且恰好含一个环，则 $G$ 是 **基环树**。
- 若 $H$ 弱连通，且每个点出度恰为 $1$，则 $H$ 是 **内向基环树**。
- 若 $H$ 弱连通，且每个点入度恰为 $1$，则 $H$ 是 **外向基环树**。
- 若 $G$ 连通，且每条边都在一个环里，则 $G$ 是 **仙人掌**。
- 若一张图的点集分为两部分后，每个部分内部没有连边，则它是 **二分图**。在此基础上若任意两个来自不同部分的点之间都有连边，则它是 **完全二分图**。

多个特殊图可以构成一个图的集合：

- 多棵树构成 **森林**。
- 多棵基环树构成 **基环森林**。
- 多棵内向基环树构成 **内向基环森林**。
- 多棵外向基环树构成 **外向基环森林**。
- 多棵仙人掌构成 **沙漠**。

一些特殊图有特殊的记法：

- $K_n$ 是 $n$ 阶完全图。
- $N_n$ 是 $n$ 阶空图。
- $C_n$ 是 $n(n>2)$ 阶环图。
- $P_n$ 是 $n$ 阶链。
- $W_n$ 是 $n+1(n>2)$ 阶轮图。
- $S_n$ 是 $n+1(n>0)$ 阶菊花图。
- $K_{n,m}$ 是两个部分分别有 $n$ 和 $m$ 个节点的完全二分图。

一些特殊图满足一些性质：

- 完全图有 $\dfrac{n(n+1)}{2}$ 条边。
- 树有 $n-1$ 条边。

## 二叉树

单独开了个大标题，因为初赛真的很喜欢考二叉树。

记一棵有根树 $G=(V, E)$：

- 若 $G$ 中每个节点最多只有两个儿子，则 $G$ 是一棵 **二叉树**。
- 若 $G$ 是一棵二叉树，且每个节点要么是叶子，要么有 $2$ 个儿子，则 $G$ 是一棵 **完整二叉树**。
- 若 $G$ 是一棵二叉树，且只有最后一层节点不满，且最后一层节点都集中在最左边的连续位置上，则 $G$ 是一棵 **完全二叉树**。
- 若 $G$ 是一棵二叉树，且叶子节点都在同一层，且非叶子节点都有 $2$ 个儿子，则 $G$ 是一棵 **完美二叉树（满二叉树）**。

完全二叉树的节点总数是叶子的两倍再减一。

完美二叉树的节点数是 $2^d-1$，$d$ 是树的深度。

初赛还很喜欢考先/中/后序遍历。

=== "先序遍历"

    根据 **根、左、右** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            res.push_back(now->val);
            dfs(now->left);
            dfs(now->right);
        }
    }
    ```

=== "中序遍历"

    根据 **左、根、右** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            dfs(now->left);
            res.push_back(now->val);
            dfs(now->right);
        }
    }
    ```

=== "后序遍历"

    根据 **左、右、根** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            dfs(now->left);
            dfs(now->right);
            res.push_back(now->val);
        }
    }
    ```

知道中序遍历序列和其他任意一个序列可以反推出整棵树，只需依照以下步骤：

1. 前序序列中第一个是根，后续序列中最后一个是根。
2. 确定根之后，中序遍历序列中，根左边是左子树，根右边是右子树。
3. 递归。

## 语言知识

讲一点在算法竞赛中不是很常用的。

### 动态分配内存

``` cpp
int *ptr = nullptr; // 这个指针初始为空

ptr = new int; // 请求了一个 int 的内存

delete ptr; // 释放指向的内存
```

``` cpp
int *ptr = nullptr; // 这个指针初始为空

ptr = new int[10]; // 请求了 10 个 int 的内存

delete[] ptr; // 释放这 10 个 int

// 那二维数组怎么办呢？
// 我们可以把第一维存储的东西看作指针，指向第二维数组
// 假设第一维长度为 n，第二维长度 m

// 申请
int **arr = nullptr;
arr = new int*[n];
for(int i=0; i<n; i++) arr[i] = new int[m];

// 释放
for(int i=0; i<n; i++) delete[] arr[i];
delete[] arr;

// 三维数组同理！
int ***qwq = nullptr;
qwq = new int**[n];
for(int i=0; i<n; i++) {
    qwq[i] = new int*[m];
    for(int j=0; j<m; j++) {
        qwq[i][j] = new int[k];
    }
}
```

### class 与 struct

1. class 默认访问权是 `private`，struct 默认 `public`。
2. 关于构造函数
    - class 不定义构造函数时，若成员变量都是 `public` 的，那么可以使用大括号初始化，反之不可以。
    - class 定义了构造函数时，不可以用大括号初始化。
    - struct 不定义构造函数时，可以使用大括号初始化。
    - struct 定义了构造函数时，不可以用大括号初始化。

### union

洛谷 SCP2023 考了就顺便讲一下，这个东西就是可以让若干个变量共用一块内存，`sizeof` 它实际输出的是其中最大变量占用了多少。

## 终于写完了！

真的很累人啊 QAQ 如果有什么遗漏了欢迎来补充。