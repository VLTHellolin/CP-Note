---
comments: true
---

# 初赛总结

祝各位看完本文后 CSP/NOIP RP++！

## 计算机史

| 名称 | 年代 | 发明 / 制造人 | 代表机型 |
| --- | ---- | ---------- | ------ |
| 真空管计算机 | 1801 | 法国人约瑟夫·杰夸德 | 打孔卡 |
| 真空管计算机 | 1822、1837 | 英国人查尔斯·巴贝奇（“电脑之父”） | 差分机、分析机 |
| 真空管计算机 | 1946 | 美国人莫克利以及艾克特 | ENIAC（埃尼阿克） |
| 晶体管计算机 | 1954 | 美国贝尔实验室 | TRADIC（催迪克） |
| 集成电路计算机 | 1958 | 美国人杰克·基尔比 | IBM 的 System/360 |
| 超大规模集成电路计算机 | 1977 | \ | ILLIAC-IV、Macintosh |
| 智能计算机 | 至今 | \ | \ |

## 计算机学奖项

### 图灵奖

**图灵奖**（ACM Turing Award），由 ACM 于 1966 年设立，授予对象是 **为计算机科学作出重要贡献的个人**。是计算机最高奖项（“计算机界的诺贝尔奖”）。

图灵奖获得者见 [维基百科](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96)，[姚期智](https://zh.wikipedia.org/wiki/%E5%A7%9A%E6%9C%9F%E6%99%BA) 是 **唯一一位获此奖的华人** ，于 2000 年获得图灵奖。清华大学的 **姚班** 就是以他命名的。

### 约翰·冯·诺依曼奖

**约翰·冯·诺依曼奖**（IEEE John von Neumann Medal），由 IEEE 于 1990 年设立，目的是 **表扬在计算机科学和技术上具有杰出成就的科学家**。

## 计算机构成

**微型计算机** 分为 **硬件系统** 和 **软件系统**，**硬件系统** 分主板、CPU、存储器（内存储器、外存储器）、电源、I/O 设备等，**软件系统** 分系统软件（操作系统、诊断程序等）和应用软件。

### 中央处理器（CPU）

CPU 的功能是 **解释计算机指令以及处理计算机软件中的数据**。

CPU 由 **运算器、控制器和存储器** 组成。

几乎所有的冯·诺伊曼 CPU 的运作原理可分为四个阶段：**提取、解码、执行和写回**。

CPU 的 **主频=外频×倍频**。CPU 性能取决于 **时钟频率** 和 **IPC**（每周期可处理的指令），IPS（每秒可处理的指令）就是时钟频率和 IPC 的结合。

### 存储器

#### 随机存取存储器（RAM）

RAM 是 **内存储器**。

RAM 与中央处理器直接交换数据。

#### 只读存储器（ROM）

ROM 是 **内存储器**。

一旦存储了资料不可再改写。其中的数据不会因为断电而丢失。

BIOS（Basic Input and Output System，基本输入输出系统）就是一组固化到主板上的 ROM 内的程序，其为计算机提供最底层、最直接的硬件控制，其中保存着计算机的自检程序、自启动程序等。

### 外存储器

外存储器包括硬盘、光盘等。

### 输入输出（I/O）设备

键盘、鼠标、扫描仪、相机等都是输入设备。

打印机、投影仪、显示器、扬声器等都是输出设备。

也有双向的设备，RAM、触摸屏、USB、刻录机等都是双向设备。

### 断电后可不可以保存数据？

可以：ROM、外存储器。

不可以：CPU、RAM。

## 编程语言

编程语言分为低级语言和高级语言。

常见低级语言是汇编语言。

常见高级语言有 C/C++、Fortan、Java 等。

面向过程的语言有 C、Fortan、Pascal、Basic 等。

面向对象的语言有 C++、Java、Javascript、Swift、PHP、Ruby、Objective-C 等。

**低级语言和高级语言的主要区别** 是低级语言常数小、运行快，而高级语言需要编译/解释，常数大、运行慢，但可移植性高。

## 存储单位

!!! warning

    微软操作系统中经常混用 MB、MiB 等存储单位，**在考试中出现的 MB 一般指 MiB，GB 一般指 GiB**，请仔细辨别。

常用的存储单位有 **B / KB / KiB / MB / MiB / GB / GiB / TB / TiB / PB / PiB** 等。**B** 指字节（Byte）。

不带 **i** 的这些 Bytes，进位关系是 **1000**。

带 **i** 的这些 Bytes，进位关系是 **1024**。

还有一种单位是 **b** 比特（bit），相应的有 **Kb / Kib / Mb / Mib** 等。

**1B = 8b**，一字节含有八个比特，比特是二进制下的一位内存。

## Linux、编译工具、IDE 或编辑器、调试工具

多用用就会了。

## 进制转换

**Hex** 表示 Hexadecimal，16 进制。

**Dec** 表示 Decimal，10 进制。

**Oct** 表示 Octomary，8 进制。

**Bin** 表示 Binary，2 进制。

### 十进制转 k 进制

短除法，把十进制数每次除以 $k$ 求余数，最后把余数倒序排列即可。

小数就是换成乘法，将取整结果写出，正序排列即可。

### k 进制转十进制

第 $i$ 为乘上 $k^{i-1}$，相加即可。

小数就是变为负指数。

### x 进制转 y 进制

x 进制转到十进制再转 y 进制。

## 二进制

计算机计算使用二进制。

**原码** 就是将十进制数直接转换为二进制数形成的二进制编码。

**反码** 正数的反码是自己，负数地反码是除了符号位全部按位取反地结果。

**补码** 正数的补码是自己，负数的补码是反码加一。

## 位运算

### 按位与运算（&）

两个二进制数进行与运算，如果对应位上两数都为 $1$，则该位为 $1$，反之为 $0$。

### 按位或运算（|）

两个二进制数进行或运算，如果对应位上两数都为 $0$，则该位为 $0$，反之为 $1$。

### 异或运算（^）

两个二进制数进行异或运算，如果对应位上两数不同，则该位为 $1$，反之为 $0$。

异或满足交换律和结合律。

一个数异或 $0$ 是他自己，异或他自己是 $0$。

### 按位取反（~）

就是将一个二进制数的各位数码都取反，包括符号位。

### 左移运算（<<）

将一个二进制数整体向左移动若干位，低位用 $0$ 补全。

### 右移运算（>>）

将一个二进制数整体向右移动若干位，多余的舍去。

### 位运算优先级

从高到低：

按位取反、位移、按位与、异或、按位或。

### 常用技巧

**lowbit（取出最后一个 1）**：`a & (-a)`。

**取得第 x 位**：`a & (1 << x)`。

**设置第 x 位为 1**：`a |= (1 << x)`。

**设置第 x 位为 0**：`a &= ~(1 << x)`。

## 逻辑运算

### 逻辑与（&&）

数学中记作 $\land$。

两个逻辑变量都为真时，结果为真，反之为假。

### 逻辑或（||）

数学中记作 $\lor$。

两个逻辑变量都为假时，结果为假，反之为真。

### 逻辑非（!）

数学中记作 $\lnot$。

该逻辑变量为真时，结果为假，反之为真。

### 逻辑运算优先级

从高到低：

非、与、或。

### 真、假

在 C++ 中，真表示为 `true`，任何非 $0$ 值转换到 `bool` 类型都是 `true`。

假表示为 `false`，$0$ 值转换到 `bool` 类型是 `false`。

## 组合数学

咱也不知道为啥初赛特别喜欢考排列组合。

建议学一学（or 复习）数学选修二相关内容。

### 排列

$n$ 个不同元素中选 $m$ 个元素，考虑顺序。

$n=m$ 时称为全排列。

$P^m_n=\dfrac{n!}{(n-m)!}$

### 组合

$n$ 个不同元素中选 $m$ 个元素，不考虑顺序。

计算组合数就是计算对应排列数后把顺序除掉就好了。

$C^m_n=\dfrac{P^m_n}{P^m_m}=\dfrac{n!}{m!(n-m)!}$

## 数据结构

### 栈（Stack）

栈是后进先出的，称为 LIFO（Last In First Out）表。

### 队列（Queue）

队列是先进先出的，称为 FIFO（First In First Out）表。

## 链表（List）

链表插入删除 $O(1)$，随机访问 $O(n)$。数组正好相反。

常见链表的声明形式：

=== "单向链表"

    存储数据和他的后继。

    ``` cpp 
    template <class T>
    struct node {
        T val;
        node *nxt;
    };
    ```

=== "双向链表"

    存储数据、他的前驱和后继。

    ``` cpp
    template <class T>
    struct node {
        T val;
        node *prv, *nxt;
    };
    ```

初赛常考的就是要在链表中插入 / 删除元素，给你列四个选项判断哪个正确 / 错误，这个时候我们需要注意的就是修改的顺序。

``` cpp
// 示例：双向链表，在 x 后插入 y

// 这段代码是正确的
y->nxt = x->nxt; // 插入后，x 的后继变成了 y 的后继
x->nxt->prv = y; // 插入后，x 的后继的前驱变成了 y
y->prv = x; // y 的前驱是 x
x->nxt = y; // x 的后继是 y

// 这段代码是错误的
y->prv = x;
y->nxt = x->nxt;
x->nxt = y;
x->nxt->prv = y; // 此时因为上一句的修改，x 的后继已经成为 y 了，y 的前驱不可能是 y 吧？
```

链表可能是初赛常考的数据结构中最抽象、最不好懂的，可以在纸上自己练习一下。

## 字符串（String）

没啥好讲的。

$|s|$ 指字符串 $s$ 的长度。

子串是从字符串的某个位置开始取若干个字符组成的字符串，空串是任何字符串的子串。子串个数计算：$\dfrac{n(n+1)}{2}+1$。

子序列是在字符串中删除若干字符组成的字符串。

字典序比较就是以第 $i$ 个字符作为第 $i$ 关键字比较，一般而言空字符小于任何字符。

## 图论

### 一些基本概念

若对于两个点 $u, v$，若存在边 $(u, v)$，称 $u, v$ 是 **相邻的**。

与一个点 $u$ 关联的边数记作他的 **度数**，下记点 $u$ 的度数为 $\deg(u)$。

**无向图中度数是边数的两倍（握手定理）**，形式化地，$2|E| = \sum\limits_{x\in V} \deg(x)$。

若 $\deg(u)=0$，$u$ 是 **孤立点**。若 $\deg(u)=1$，$u$ 是 **叶节点**。若 $2\mid \deg(u)$，$u$ 是 **偶点**，反之 $u$ 是 **奇点**。

---

**自环** 就是一条边 $e=(u, v)$ 满足 $u=v$。

**重边** 就是存在两条边完全相等。

不存在自环、重边的图是 **简单图**，反之是 **多重图**。

---

**稀疏图** 就是满足 $|V|^2\gg |E|$ 的图，**稠密图** 就是满足 $|V|^2\approx |E|$ 的图。

### 连通性

记一个无向图 $G=(V, E)$，有向图 $H=(V', E')$：

- 若 $G$ 中任意两个顶点均连通，则 $G$ 是 **连通图**。
- 若 $G$ 存在一个连通子图 $G'$，并且不存在任意的连通图 $G''$ 使得 $G'\subsetneq G''\subseteq G$，则 $G'$ 是 $G$ 是的一个 **连通分量**。
- 若 $H$ 中任意两个顶点可互相到达，则 $H$ 是 **强连通图**。
- 若将 $H$ 转换为无向图后图连通，则 $H$ 是 **弱连通图**。
- 根据连通分量的定义，同样也有 **强连通分量** 和 **弱连通分量**。

### 一些特殊的图

记一个无向简单图 $G=(V, E)$，有向简单图 $H=(V', E')$：

- 若 $G$ 中任意两点之间均有边，则 $G$ 是 **完全图**。
- 若 $H$ 中任意两点之间均有两条方向不同的边，则 $H$ 是 **有向完全图**。
- 若 $H$ 中任意两点之间恰有一条边，则 $H$ 是 **竞赛图**。
- 若 $E=\varnothing$，则该图是一张 **空图（零图）**。
- 若 $G$ 中所有边恰好构成一个圆圈，则 $G$ 是 **环图**。
- 若 $G$ 中所有边恰好构成一条路径，则 $G$ 是 **链**。链就是环图删去一条边。
- 若 $G$ 中存在一个支配点 $u$ 满足其余点两两之间没有边，则 $G$ 是 **菊花图**。
- 若 $G$ 中存在一个支配点 $u$ 满足其余点之间的边构成一个圆圈，则 $G$ 是 **轮图**。
- 若 $G$ 连通，且不含环，则 $G$ 是 **树**。
- 若 $G$ 连通，且恰好含一个环，则 $G$ 是 **基环树**。
- 若 $H$ 弱连通，且每个点出度恰为 $1$，则 $H$ 是 **内向基环树**。
- 若 $H$ 弱连通，且每个点入度恰为 $1$，则 $H$ 是 **外向基环树**。
- 若 $G$ 连通，且每条边都在一个环里，则 $G$ 是 **仙人掌**。
- 若一张图的点集分为两部分后，每个部分内部没有连边，则它是 **二分图**。在此基础上若任意两个来自不同部分的点之间都有连边，则它是 **完全二分图**。

多个特殊图可以构成一个图的集合：

- 多棵树构成 **森林**。
- 多棵基环树构成 **基环森林**。
- 多棵内向基环树构成 **内向基环森林**。
- 多棵外向基环树构成 **外向基环森林**。
- 多棵仙人掌构成 **沙漠**。

一些特殊图有特殊的记法：

- $K_n$ 是 $n$ 阶完全图。
- $N_n$ 是 $n$ 阶空图。
- $C_n$ 是 $n(n>2)$ 阶环图。
- $P_n$ 是 $n$ 阶链。
- $W_n$ 是 $n+1(n>2)$ 阶轮图。
- $S_n$ 是 $n+1(n>0)$ 阶菊花图。
- $K_{n,m}$ 是两个部分分别有 $n$ 和 $m$ 个节点的完全二分图。

一些特殊图满足一些性质：

- 完全图有 $\dfrac{n(n+1)}{2}$ 条边。
- 树有 $n-1$ 条边。

## 二叉树

单独开了个大标题，因为初赛真的很喜欢考二叉树。

记一棵有根树 $G=(V, E)$：

- 若 $G$ 中每个节点最多只有两个儿子，则 $G$ 是一棵 **二叉树**。
- 若 $G$ 是一棵二叉树，且每个节点要么是叶子，要么有 $2$ 个儿子，则 $G$ 是一棵 **完整二叉树**。
- 若 $G$ 是一棵二叉树，且只有最后一层节点不满，且最后一层节点都集中在最左边的连续位置上，则 $G$ 是一棵 **完全二叉树**。
- 若 $G$ 是一棵二叉树，且叶子节点都在同一层，且非叶子节点都有 $2$ 个儿子，则 $G$ 是一棵 **完美二叉树（满二叉树）**。

完全二叉树的节点总数是叶子的两倍再减一。

完美二叉树的节点数是 $2^d-1$，$d$ 是树的深度。

初赛还很喜欢考先/中/后序遍历。

=== "先序遍历"

    根据 **根、左、右** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            res.push_back(now->val);
            dfs(now->left);
            dfs(now->right);
        }
    }
    ```

=== "中序遍历"

    根据 **左、根、右** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            dfs(now->left);
            res.push_back(now->val);
            dfs(now->right);
        }
    }
    ```

=== "后序遍历"

    根据 **左、右、根** 的顺序遍历。

    ``` cpp
    std::vector<int> res;
    void dfs(node *now) {
        if (now != nullptr) {
            dfs(now->left);
            dfs(now->right);
            res.push_back(now->val);
        }
    }
    ```

知道中序遍历序列和其他任意一个序列可以反推出整棵树，只需依照以下步骤：

1. 前序序列中第一个是根，后续序列中最后一个是根。
2. 确定根之后，中序遍历序列中，根左边是左子树，根右边是右子树。
3. 递归。

## 语言知识

### 动态分配内存

``` cpp
int *ptr = nullptr; // 这个指针初始为空

ptr = new int; // 请求了一个 int 的内存

delete ptr; // 释放指向的内存
```

``` cpp
int *ptr = nullptr; // 这个指针初始为空

ptr = new int[10]; // 请求了 10 个 int 的内存

delete[] ptr; // 释放这 10 个 int

// 那二维数组怎么办呢？
// 我们可以把第一维存储的东西看作指针，指向第二维数组
// 假设第一维长度为 n，第二维长度 m

// 申请
int **arr = nullptr;
arr = new int*[n];
for(int i=0; i<n; i++) arr[i] = new int[m];

// 释放
for(int i=0; i<n; i++) delete[] arr[i];
delete[] arr;

// 三维数组同理！
int ***qwq = nullptr;
qwq = new int**[n];
for(int i=0; i<n; i++) {
    qwq[i] = new int*[m];
    for(int j=0; j<m; j++) {
        qwq[i][j] = new int[k];
    }
}
```

### class 与 struct

1. class 默认访问权是 `private`，struct 默认 `public`。
2. 关于构造函数
    - class 不定义构造函数时，若成员变量都是 `public` 的，那么可以使用大括号初始化，反之不可以。
    - class 定义了构造函数时，不可以用大括号初始化。
    - struct 不定义构造函数时，可以使用大括号初始化。
    - struct 定义了构造函数时，不可以用大括号初始化。

## 终于写完了！

真的很累人啊 QAQ 如果有什么遗漏了欢迎来补充。